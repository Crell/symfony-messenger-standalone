#!/usr/bin/env php
<?php

require __DIR__ . '/../vendor/autoload.php';

use Doctrine\DBAL\DriverManager;
use Hellpat\Container;
use Hellpat\DispatchTextMessageCommand;
use Hellpat\SyncTextMessage;
use Hellpat\SyncTextMessageHandler;
use Hellpat\AsyncTextMessage;
use Hellpat\AsyncTextMessageHandler;
use Psr\Log\LogLevel;
use Symfony\Component\Console\Application;
use Symfony\Component\ErrorHandler\Debug;
use Symfony\Component\EventDispatcher\EventDispatcher;
use Symfony\Component\HttpKernel\Log\Logger;
use Symfony\Component\Messenger\Bridge\Doctrine\Transport\Connection;
use Symfony\Component\Messenger\Bridge\Doctrine\Transport\DoctrineTransport;
use Symfony\Component\Messenger\Command\ConsumeMessagesCommand;
use Symfony\Component\Messenger\Command\FailedMessagesRemoveCommand;
use Symfony\Component\Messenger\Command\FailedMessagesRetryCommand;
use Symfony\Component\Messenger\Command\FailedMessagesShowCommand;
use Symfony\Component\Messenger\EventListener\SendFailedMessageToFailureTransportListener;
use Symfony\Component\Messenger\Handler\HandlersLocator;
use Symfony\Component\Messenger\MessageBus;
use Symfony\Component\Messenger\Middleware\FailedMessageProcessingMiddleware;
use Symfony\Component\Messenger\Middleware\HandleMessageMiddleware;
use Symfony\Component\Messenger\Middleware\SendMessageMiddleware;
use Symfony\Component\Messenger\RoutableMessageBus;
use Symfony\Component\Messenger\Transport\Sender\SendersLocator;
use Symfony\Component\Messenger\Transport\Serialization\PhpSerializer;

Debug::enable();

$logger = new Logger(LogLevel::DEBUG);

$messageTransport = new DoctrineTransport(
    new Connection([
        'table_name' => 'messages',
        'queue_name' => 'default',
        'auto_setup' => true,
        // ...
    ], DriverManager::getConnection([
        'url' => 'sqlite:///db.sqlite',
    ])),
    new PhpSerializer()
);

$failureTransport = new DoctrineTransport(
    new Connection([
        'table_name' => 'failed_messages',
        'auto_setup' => true,
        // ...
    ], DriverManager::getConnection([
        'url' => 'sqlite:///db.sqlite',
    ])),
    new PhpSerializer()
);

$eventDispatcher = new EventDispatcher();
$eventDispatcher->addSubscriber(
    new SendFailedMessageToFailureTransportListener(
        $failureTransport,
        $logger
    )
);

$messageBus = new MessageBus([
    // If the message has an SentToFailureTransportStamp (added by the SendFailedMessageToFailureTransportListener)
    // we add an ReceivedStamp (which implements NonSendableStampInterface).
    // So the Failed message cannot be sent again.
    new FailedMessageProcessingMiddleware(),
    // Order of the middlewares is important.
    // Depending on the middleware the next middleware MAY get called.
    // If the message CAN be send, the SendMessageMiddleware does not execute
    // subsequent Middlewares
    new SendMessageMiddleware(
        new SendersLocator(
            [
                // The sender handles out AsyncTextMessage but does not
                // handle the SyncTextMessage.
                // The SyncTextMessage will then be passed to the next Middleware.
                // (See new HandleMessageMiddleware(...) some lines later
                AsyncTextMessage::class => ['messenger.send_messages']
            ],
            Container::servicesById([
                'messenger.send_messages' => $messageTransport,
            ])
        )
    ),
    new HandleMessageMiddleware(new HandlersLocator([
        AsyncTextMessage::class => [
            // Every message can have multiple handlers but MUST have at least one handler.
            // You can allow Messages without handler by configuring the
            // HandleMessageMiddlewares second constructor parameter ($allowNoHandlers)
            new AsyncTextMessageHandler($logger),
        ],
        SyncTextMessage::class => [
            new SyncTextMessageHandler($logger),
        ],
    ])),
]);

$application = new Application();

// Registers a command that produced stupid sample messages
$application->add(new DispatchTextMessageCommand($messageBus));

$application->add(new ConsumeMessagesCommand(
    new RoutableMessageBus(
        // My Bus-Locator is empty at the moment, because I did not
        // implement any Messages with a Symfony\Component\Messenger\Stamp\BusNameStamp
        Container::servicesById([]),
        // Defines a Fallback MessageBus which will be used for all messages
        // that don't have a Symfony\Component\Messenger\Stamp\BusNameStamp
        // At the moment there is no single message with this stamp
        $messageBus
    ),
    Container::servicesById([
        'default_receiver' => $messageTransport,
    ]),
    $eventDispatcher
));

$application->add(new FailedMessagesShowCommand(
    'failed_receiver',
    $failureTransport
));

$application->add(new FailedMessagesRetryCommand(
    'failed_receiver',
    $failureTransport,
    $messageBus,
    $eventDispatcher,
    $logger
));

$application->add(new FailedMessagesRemoveCommand('failed_receiver', $failureTransport));

$application->run();