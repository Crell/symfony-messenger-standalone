#!/usr/bin/env php
<?php

require __DIR__.'/../vendor/autoload.php';

use Doctrine\DBAL\DriverManager;
use Hellpat\Container;
use Hellpat\DispatchTextMessageCommand;
use Hellpat\SyncTextMessage;
use Hellpat\SyncTextMessageHandler;
use Hellpat\TextMessage;
use Hellpat\TextMessageHandler;
use Symfony\Component\Console\Application;
use Symfony\Component\ErrorHandler\Debug;
use Symfony\Component\EventDispatcher\EventDispatcher;
use Symfony\Component\Messenger\Bridge\Doctrine\Transport\Connection;
use Symfony\Component\Messenger\Bridge\Doctrine\Transport\DoctrineReceiver;
use Symfony\Component\Messenger\Bridge\Doctrine\Transport\DoctrineSender;
use Symfony\Component\Messenger\Command\ConsumeMessagesCommand;
use Symfony\Component\Messenger\Envelope;use Symfony\Component\Messenger\Handler\HandlersLocator;
use Symfony\Component\Messenger\MessageBus;
use Symfony\Component\Messenger\Middleware\HandleMessageMiddleware;use Symfony\Component\Messenger\Middleware\SendMessageMiddleware;
use Symfony\Component\Messenger\RoutableMessageBus;
use Symfony\Component\Messenger\Transport\Sender\SendersLocatorInterface;

Debug::enable();

$dbalConnection = DriverManager::getConnection([
    'url' => 'sqlite:///db.sqlite',
]);

$doctrineMessengerConnection = new Connection([
    'table_name' => 'messages',
    'queue_name' => 'default',
    'auto_setup' => true,
    // ...
], $dbalConnection);

$doctrineSender = new DoctrineSender($doctrineMessengerConnection);

$sendersLocator = new class($doctrineSender) implements SendersLocatorInterface {
    public function __construct(private DoctrineSender $doctrineSender) {}

    public function getSenders(Envelope $envelope): iterable
    {
        if ($envelope->getMessage() instanceof SyncTextMessage) {
            // If the Message has no sender, the sender Middleware
            // calls the next Middleware in the Middleware-Stack of the
            // MessageBus.
            return null;
        }

        // One or multiple SenderInterface implementations for this message
        yield $this->doctrineSender;
    }
};

$messageBus = new MessageBus([
    // Order of the middlewares is important.
    // Depending on the middleware the next middleware MAY get called.
    // If the message CAN be send, the SendMessageMiddleware does not execute
    // subsequent Middlewares
    new SendMessageMiddleware($sendersLocator),
    new HandleMessageMiddleware(new HandlersLocator([
        TextMessage::class => [
            // Every message can have multiple handlers but MUST have at least one handler.
            // You can allow Messages without handler by configuring the
            // HandleMessageMiddlewares second constructor parameter ($allowNoHandlers)
            new TextMessageHandler(),
        ],
        SyncTextMessage::class => [
            new SyncTextMessageHandler(),
        ],
    ])),
]);

$application = new Application();

// Registers a command that produced stupid sample messages
$application->add(new DispatchTextMessageCommand($messageBus));

$application->add(new ConsumeMessagesCommand(
    new RoutableMessageBus(
        // My Bus-Locator is empty at the moment, because I did not
        // implement any Messages with a Symfony\Component\Messenger\Stamp\BusNameStamp
        Container::servicesById([]),
        // Defines a Fallback MessageBus which will be used for all messages
        // that don't have a Symfony\Component\Messenger\Stamp\BusNameStamp
        // At the moment there is no single message with this stamp
        $messageBus
    ),
    Container::servicesById([
        'default_receiver' => new DoctrineReceiver($doctrineMessengerConnection),
    ]),
    new EventDispatcher()
));

$application->run();